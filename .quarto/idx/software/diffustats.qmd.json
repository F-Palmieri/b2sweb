{"title":"diffuStats: compute diffusion scores over networks","markdown":{"yaml":{"title":"diffuStats: compute diffusion scores over networks","author":[{"name":"Sergio Picart-Armada","affiliation":"B2SLab at Polytechnic University of Catalonia","email":"sergi.picart@upc.edu"},{"name":"Alexandre Perera-Lluna","affiliation":"B2SLab at Polytechnic University of Catalonia"}],"date":"2021-02-02","package":"`r BiocStyle::pkg_ver('diffuStats')`","format":"html","execute":{"warning":false,"message":false,"echo":true,"eval":true},"cache":true},"headingText":"diffuStats: compute diffusion scores over networks","containsRefs":false,"markdown":"\n\n\n## Introduction\n\nThe general purpose `diffuStats` R package offers a collection of seven network propagation scores and five graph kernels. Those find application in ubiquitous computational biology applications, being one representative example the propagation of genetic information (e.g. disease-associated genes) in a gene-gene or a protein-protein interaction network. A distinctive feature of `diffuStats` is the implementation of statistically normalised scores, which address the recurrent question of how would the propagation of a randomised input look. It offers parametric, exact z-scores as well as permutation-based empirical probabilities.\n\nThe `diffuStats` software was published in:\n\n> Picart-Armada, S., Thompson, W. K., Buil, A., & Perera-Lluna, A. (2018). diffuStats: an R package to compute diffusion-based scores on biological networks. Bioinformatics, 34(3), 533-534.\n\nGeneral guidelines on how to choose the scores, along with mathematical properties of the normalised and unnormalised scores, were published in:\n\n> Picart-Armada, S., Thompson, W. K., Buil, A., & Perera-Lluna, A. (2020). The effect of statistical normalisation on network propagation scores. Bioinformatics, btaa896.\n\nFrom versions 1.10.2/1.11.2 onwards, `diffuStats` provides functions to export the exact statistical moments (means and variances), see `?moments`. Now the users can characterise the systematic biases in the diffusion scores in their domain of application.\n\n## Installation\n\n`diffuStats` is part of Bioconductor, and can be installed using\n\n```{r}\nBiocManager::install(\"diffuStats\")\n```\n\nFor the development version, you can also install the package through `R CMD INSTALL` or through `devtools::install_github(\"b2slab/diffuStats\")`, which points to its [GitHub repository](https://github.com/b2slab/diffuStats).\n\n# Getting started\n\n`diffuStats` is an R package providing several scores for diffusion in networks. While its original purpose lies on biological networks, its usage is not limited to that scope. In general terms, `diffuStats` builds several propagation algorithms on the \\code{igraph} package [@igraph] classes and methods. A more detailed analysis and documentation of the implemented methods can be found in the protein function prediction vignette.\n\nTo get started, we will load a toy graph included in the package.\n\n```{r}\nlibrary(diffuStats)\ndata(\"graph_toy\")\n```\n\nLet's take a look in the graph:\n\n```{r}\ngraph_toy\nplot(graph_toy)\n```\n\nIn the next section, we will be running diffusion algorithms on this tiny lattice graph.\n\n# Specifying the input\n\nThe package `diffuStats` is flexible and allows several inputs at once for a given network. The input format is, in its most general form, a list of matrices, where each matrix contains measured nodes in rows and specific scores in columns. **Differents sets of scores may have different backgrounds**, meaning that we can specifically tag sets of nodes as **unlabelled**. If we dispose of a unique list of nodes for label propagation, we should provide a list with a unique column vector that contains `1`'s in the labels in the list and `0`'s otherwise.\n\nIn this example data, the graph contains one input already.\n\n```{r}\ninput_vec <- graph_toy$input_vec\n\nhead(input_vec, 15)\n```\n\nLet's check how many nodes have values\n\n```{r}\nlength(input_vec)\n```\n\nWe see that all the nodes have a measure in each of the four score sets. In practice, these score sets could be disease genes, pathways, et cetera.\n\n# The diffusion algorithm\n\nEach one of these columns in the input can be *smoothed* using the network and new value will be derived - unlabelled nodes are also scored. This is the main purpose of diffusion: to derive new scores that intend to keep the same trends as the scores in the input, but taking into account the network structure. Equivalently, this can be regarded as a label propagation where positive and negative examples propagate their labels to their neighbouring nodes.\n\nLet's start with the simplest case of diffusion: only a vector of values is to be smoothed. Note that these **values must be named and must be a subset or all of the graph nodes**.\n\n```{r}\noutput_vec <- diffuStats::diffuse(\n    graph = graph_toy, \n    method = \"raw\", \n    scores = input_vec)\n\nhead(output_vec, 15)\n```\n\n# Diffusion scores visualisation\n\nThe best way to visualise the scores is overlaying them in the original lattice. `diffuStats` also comes with basic mapping functions for graphical purposes. Let's see an example:\n\n```{r}\nigraph::plot.igraph(\n    graph_toy, \n    vertex.color = diffuStats::scores2colours(output_vec),\n    vertex.shape = diffuStats::scores2shapes(input_vec),\n    main = \"Diffusion scores in our lattice\"\n)\n```\n\nHere, we have mapped the scores to colours using `scores2colours` and we have highlighted the nodes that were in the original input using `scores2shapes` on the original scores. Square nodes were labelled as relevant in the input, and the diffusion algorithm smoothed these labels over the network - as in the guilt-by-association principle.\n\n# Several inputs, several smoothing scores\n\nThe input to `diffuse` can be more than a vector with scores. It can be provided with a set of score vectors, stored in a matrix by columns, where rownames should contain the nodes that are being scored. As different score sets might have different labelled/unlabelled nodes, `diffuse` also accepts a list of score matrices that may have a different amount of rows.\n\nIn this section, we will diffuse using a matrix of scores that contains four sets of scores, with four different names. These example names refer to what the input contains:\n\n-   Single: a single node is labelled as positive\n-   Row: a row of nodes in the lattice graph are positives\n-   Small_sample: a randomly generated small sample of the lattice nodes are positives\n-   Large_sample: a randomly generated sample with half of the lattice nodes are positives\n\n```{r}\ninput_mat <- graph_toy$input_mat\n\nhead(input_mat)\n```\n\nOn the other hand, there are a variety of methods to compute the diffusion scores. At the moment, the following: `raw`, `ml` and `gm` for classical propagation; `z` and `mc` for scores normalised through a statistical model, and similarly `ber_s` and `ber_p`, as described in [@mosca]. The scoring methods `mc` and `ber_p` require permutations -thus being computationally intense- whereas the rest are deterministic.\n\nFor instance, let's smooth through `mc` the input matrix:\n\n```{r}\noutput_mc <- diffuStats::diffuse(\n    graph = graph_toy, \n    method = \"mc\", \n    scores = input_mat)\n\nhead(output_mc)\n```\n\nWe can plot the result of the fourth column *Large_sample*:\n\n```{r}\nscore_col <- 4\nigraph::plot.igraph(\n    graph_toy, \n    vertex.color = diffuStats::scores2colours(output_mc[, score_col]),\n    vertex.shape = diffuStats::scores2shapes(input_mat[, score_col]),\n    main = \"Diffusion scores in our lattice\"\n)\n```\n\nEach method has its particularities and, in the end, it is all about the question being asked to the data and the particularities of the dataset.\n\n# Benchmarking\n\nPackage `diffuStats` offers the option to assess the performance of the diffusion scores given user-defined target scores or labels.\n\nThe validation must be supplied with the same format as the input scores, but the labels of the nodes might be different. For example, we can diffuse labels on all the nodes of a graph but evaluate using only a specific subset of nodes and target labels. A small example: we want to evaluate how good the diffusion scores `raw` and `ml` are at recovering the original labels of the first 15 nodes when diffusing in the example network.\n\n```{r}\ndf_perf <- perf(\n    graph = graph_toy,\n    scores = graph_toy$input_mat,\n    validation = graph_toy$input_mat[1:15, ],\n    grid_param = expand.grid(method = c(\"raw\", \"ml\")))\ndf_perf\n```\n\nThis indicates that both methods have a very high area under the curve in this example: the ordering of the diffusion scores is very aligned to the class label.\n\nThe last example is useful for showing a case in which diffusion scores perform poorly. As the *Small_sample* and *Large_sample* positive labels have been randomly assigned ignoring the network, diffusion is not expected to accurately predict one part of the network using as input another disjoint subset of labelled nodes. Thus, if we try to propagate the labels from nodes $1$ to $20$ and evaluate the performance using nodes from $21$ to $48$, we get a poor result:\n\n```{r}\ndf_perf <- perf(\n    graph = graph_toy,\n    scores = graph_toy$input_mat[1:20, 3:4],\n    validation = graph_toy$input_mat[21:48, 3:4],\n    grid_param = expand.grid(method = c(\"raw\", \"ml\")))\ndf_perf\n```\n\n# R session info {.unnumbered}\n\n```{r}\nsessionInfo()\n```\n\n# References\n\n## News\n\nFile `NEWS.md` keeps track of the additions and bug fixes of each package version.\n","srcMarkdownNoYaml":"\n\n# diffuStats: compute diffusion scores over networks\n\n## Introduction\n\nThe general purpose `diffuStats` R package offers a collection of seven network propagation scores and five graph kernels. Those find application in ubiquitous computational biology applications, being one representative example the propagation of genetic information (e.g. disease-associated genes) in a gene-gene or a protein-protein interaction network. A distinctive feature of `diffuStats` is the implementation of statistically normalised scores, which address the recurrent question of how would the propagation of a randomised input look. It offers parametric, exact z-scores as well as permutation-based empirical probabilities.\n\nThe `diffuStats` software was published in:\n\n> Picart-Armada, S., Thompson, W. K., Buil, A., & Perera-Lluna, A. (2018). diffuStats: an R package to compute diffusion-based scores on biological networks. Bioinformatics, 34(3), 533-534.\n\nGeneral guidelines on how to choose the scores, along with mathematical properties of the normalised and unnormalised scores, were published in:\n\n> Picart-Armada, S., Thompson, W. K., Buil, A., & Perera-Lluna, A. (2020). The effect of statistical normalisation on network propagation scores. Bioinformatics, btaa896.\n\nFrom versions 1.10.2/1.11.2 onwards, `diffuStats` provides functions to export the exact statistical moments (means and variances), see `?moments`. Now the users can characterise the systematic biases in the diffusion scores in their domain of application.\n\n## Installation\n\n`diffuStats` is part of Bioconductor, and can be installed using\n\n```{r}\nBiocManager::install(\"diffuStats\")\n```\n\nFor the development version, you can also install the package through `R CMD INSTALL` or through `devtools::install_github(\"b2slab/diffuStats\")`, which points to its [GitHub repository](https://github.com/b2slab/diffuStats).\n\n# Getting started\n\n`diffuStats` is an R package providing several scores for diffusion in networks. While its original purpose lies on biological networks, its usage is not limited to that scope. In general terms, `diffuStats` builds several propagation algorithms on the \\code{igraph} package [@igraph] classes and methods. A more detailed analysis and documentation of the implemented methods can be found in the protein function prediction vignette.\n\nTo get started, we will load a toy graph included in the package.\n\n```{r}\nlibrary(diffuStats)\ndata(\"graph_toy\")\n```\n\nLet's take a look in the graph:\n\n```{r}\ngraph_toy\nplot(graph_toy)\n```\n\nIn the next section, we will be running diffusion algorithms on this tiny lattice graph.\n\n# Specifying the input\n\nThe package `diffuStats` is flexible and allows several inputs at once for a given network. The input format is, in its most general form, a list of matrices, where each matrix contains measured nodes in rows and specific scores in columns. **Differents sets of scores may have different backgrounds**, meaning that we can specifically tag sets of nodes as **unlabelled**. If we dispose of a unique list of nodes for label propagation, we should provide a list with a unique column vector that contains `1`'s in the labels in the list and `0`'s otherwise.\n\nIn this example data, the graph contains one input already.\n\n```{r}\ninput_vec <- graph_toy$input_vec\n\nhead(input_vec, 15)\n```\n\nLet's check how many nodes have values\n\n```{r}\nlength(input_vec)\n```\n\nWe see that all the nodes have a measure in each of the four score sets. In practice, these score sets could be disease genes, pathways, et cetera.\n\n# The diffusion algorithm\n\nEach one of these columns in the input can be *smoothed* using the network and new value will be derived - unlabelled nodes are also scored. This is the main purpose of diffusion: to derive new scores that intend to keep the same trends as the scores in the input, but taking into account the network structure. Equivalently, this can be regarded as a label propagation where positive and negative examples propagate their labels to their neighbouring nodes.\n\nLet's start with the simplest case of diffusion: only a vector of values is to be smoothed. Note that these **values must be named and must be a subset or all of the graph nodes**.\n\n```{r}\noutput_vec <- diffuStats::diffuse(\n    graph = graph_toy, \n    method = \"raw\", \n    scores = input_vec)\n\nhead(output_vec, 15)\n```\n\n# Diffusion scores visualisation\n\nThe best way to visualise the scores is overlaying them in the original lattice. `diffuStats` also comes with basic mapping functions for graphical purposes. Let's see an example:\n\n```{r}\nigraph::plot.igraph(\n    graph_toy, \n    vertex.color = diffuStats::scores2colours(output_vec),\n    vertex.shape = diffuStats::scores2shapes(input_vec),\n    main = \"Diffusion scores in our lattice\"\n)\n```\n\nHere, we have mapped the scores to colours using `scores2colours` and we have highlighted the nodes that were in the original input using `scores2shapes` on the original scores. Square nodes were labelled as relevant in the input, and the diffusion algorithm smoothed these labels over the network - as in the guilt-by-association principle.\n\n# Several inputs, several smoothing scores\n\nThe input to `diffuse` can be more than a vector with scores. It can be provided with a set of score vectors, stored in a matrix by columns, where rownames should contain the nodes that are being scored. As different score sets might have different labelled/unlabelled nodes, `diffuse` also accepts a list of score matrices that may have a different amount of rows.\n\nIn this section, we will diffuse using a matrix of scores that contains four sets of scores, with four different names. These example names refer to what the input contains:\n\n-   Single: a single node is labelled as positive\n-   Row: a row of nodes in the lattice graph are positives\n-   Small_sample: a randomly generated small sample of the lattice nodes are positives\n-   Large_sample: a randomly generated sample with half of the lattice nodes are positives\n\n```{r}\ninput_mat <- graph_toy$input_mat\n\nhead(input_mat)\n```\n\nOn the other hand, there are a variety of methods to compute the diffusion scores. At the moment, the following: `raw`, `ml` and `gm` for classical propagation; `z` and `mc` for scores normalised through a statistical model, and similarly `ber_s` and `ber_p`, as described in [@mosca]. The scoring methods `mc` and `ber_p` require permutations -thus being computationally intense- whereas the rest are deterministic.\n\nFor instance, let's smooth through `mc` the input matrix:\n\n```{r}\noutput_mc <- diffuStats::diffuse(\n    graph = graph_toy, \n    method = \"mc\", \n    scores = input_mat)\n\nhead(output_mc)\n```\n\nWe can plot the result of the fourth column *Large_sample*:\n\n```{r}\nscore_col <- 4\nigraph::plot.igraph(\n    graph_toy, \n    vertex.color = diffuStats::scores2colours(output_mc[, score_col]),\n    vertex.shape = diffuStats::scores2shapes(input_mat[, score_col]),\n    main = \"Diffusion scores in our lattice\"\n)\n```\n\nEach method has its particularities and, in the end, it is all about the question being asked to the data and the particularities of the dataset.\n\n# Benchmarking\n\nPackage `diffuStats` offers the option to assess the performance of the diffusion scores given user-defined target scores or labels.\n\nThe validation must be supplied with the same format as the input scores, but the labels of the nodes might be different. For example, we can diffuse labels on all the nodes of a graph but evaluate using only a specific subset of nodes and target labels. A small example: we want to evaluate how good the diffusion scores `raw` and `ml` are at recovering the original labels of the first 15 nodes when diffusing in the example network.\n\n```{r}\ndf_perf <- perf(\n    graph = graph_toy,\n    scores = graph_toy$input_mat,\n    validation = graph_toy$input_mat[1:15, ],\n    grid_param = expand.grid(method = c(\"raw\", \"ml\")))\ndf_perf\n```\n\nThis indicates that both methods have a very high area under the curve in this example: the ordering of the diffusion scores is very aligned to the class label.\n\nThe last example is useful for showing a case in which diffusion scores perform poorly. As the *Small_sample* and *Large_sample* positive labels have been randomly assigned ignoring the network, diffusion is not expected to accurately predict one part of the network using as input another disjoint subset of labelled nodes. Thus, if we try to propagate the labels from nodes $1$ to $20$ and evaluate the performance using nodes from $21$ to $48$, we get a poor result:\n\n```{r}\ndf_perf <- perf(\n    graph = graph_toy,\n    scores = graph_toy$input_mat[1:20, 3:4],\n    validation = graph_toy$input_mat[21:48, 3:4],\n    grid_param = expand.grid(method = c(\"raw\", \"ml\")))\ndf_perf\n```\n\n# R session info {.unnumbered}\n\n```{r}\nsessionInfo()\n```\n\n# References\n\n## News\n\nFile `NEWS.md` keeps track of the additions and bug fixes of each package version.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"diffustats.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.13","editor":"visual","theme":{"light":"pulse","dark":"slate"},"title":"diffuStats: compute diffusion scores over networks","author":[{"name":"Sergio Picart-Armada","affiliation":"B2SLab at Polytechnic University of Catalonia","email":"sergi.picart@upc.edu"},{"name":"Alexandre Perera-Lluna","affiliation":"B2SLab at Polytechnic University of Catalonia"}],"date":"2021-02-02","package":"`r BiocStyle::pkg_ver('diffuStats')`"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}